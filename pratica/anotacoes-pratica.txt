docker run --rm --name  laravel -p 8000:8000 vssouza7/laravel

Expondo a porta 8000.

Como o laravel ta rodando em desenvolvimento, o serv de desenv esta programando para rodar apenasa na porta 127.0.0.1 do Container. Como Estoua cessando fora, não
estou acessando por esse endereç, então, ele não vai funcionar.
Teria que deixar esse acesso liberado para qualquer host.

Lembrando que entrypoint é o comando de entrada do nosso container, e o CMD, são os "parametros" para o entrypoinit.

O entrypoint não pode ser substituido, mas o cmd pode.

Matando o container só com o inicio do ID dele, p/ex:
docker rm -f 7de

Para rodarmos o nosso container, utilizamos o comando:
docker run --rm -d --name laravel -p 8000:8000 vssouza7/laravel

Para sabermos o que está acontecendo no nosso container, validamos o log com o seguinte comando:
docker logs <nomedocontainer>

o CMD é basicamente "anexado" ao entrypoint. O cmd também pode ser substituido. Por exemplo:
Se especificamos que o nosso container vai rodar na porta 8000 no Docker file, podemos passar o mesmo parametro quando formos subir, colocando depois das
informacoes da imagem
p/ex:
# Dockerfile
CMD ["--host=0.0.0.0"]
# Comando para subir container
docker run --rm -d --name laravel -p 8001:8001 vssouza7/laravel --host=0.0.0.0 --port=8001

Basta mapearmos os passos que fizemos no container, como instalação e preparação de ambiente, que temos um
roteiro para add no Dockerfile

Parte do NODE:
A nossa ideia agora, eh compartilhar a pasta do nosso computador, com o container que for rodar.
Pq ai consigo alterar no meu computador e ver o resultado no meu container.

Para compartilharmos o nosso volume, colocamos o parametro "-v"

Ao rodar o comando abaixo, estamos criando uma nova imagem para o Docker, iremos rodar um node 15 de forma interativa entrando no container
pelo bash, compartilhando no host 3000 e porta 3000, compartilhando o volume da nossa pasta atual, 
para a pasta do container /usr/src/app/.
Com isso, tudo que escrevermos no nosso container, vai aparecer na nossa maquina, e vice-versa
docker run --rm -it -v $(pwd)/:/usr/src/app -p 3000:3000 node:15 bash

Não existe mais compartilhamento de arquivos, quando vou gerar a minha img. Quando vou gerar minha img
eu tenho que colocar tudo dentro delas.
Quero pegar nossos arquivos da nosso projeto do visual studio, e jogar para o nosso container, ou da imagem que estou gerando.

Para isso, utilizamos o "COPY . .", ou seja, vou copiar tudo que esta na pasta que estou desenvolvendo e dando o build
e vou jogar na pasta "app" para mim.

Com o comando abaixo, outros containers podem ter acesso ao nosso container através dessa porta
Expose <numerodaporta>

Buildando o nosso projeto NODE
docker build -t vssouza7/hello-express .

Rodando para ver se os passos do nosso Dockerfile deram certo
docker run -p 3000:3000 vssouza7/hello-express:latest

Subindo a nossa imagem para os repositorios do Dockerhub
docker push vssouza7/hello-express

Uma coisa comum d e acontecer, é quando trabalhamos com mais de 1 Dockerfile, p/ex. Dockerfile e Dockerfile.prod
O prod tem o Copy, que é para copiar tudo que ta na imagem, e guarda para empacotar. 
Para darmos um docker-build somente em um Dockerfile, devemos rodar o seguinte ocmando dentro da pasta com os Dockerfiles:
docker build -t vssouza7/hello-express . -f Dockerfile.prod

Garantimos que podemos trabalhar com uma versão local e outra de publicação.

========== OTIMIZANDO AS IMGs ==========
Quando estamos trabalhando normalmente em modulo de desenv, vamos sempre utilizar uma img Docker que temos varios 
recursos instalados, no caso do PHP, trabalhamos com uma img debian aonde instalamos os pacotes via apt-get, instalamos o Laravel

Se fossemos colocar em PRD, queriamos uma img mais "enxuta", quanto menor a img, melhor. É mais rapido para subir, baixar e tem menos
chance de vulnerabilidade de segurança.

Nosso objetivo nesse capitulo agora, é gerar uma img para PRD. Ela vai ter 2 pontos importantes, vamos colocar o nginx como
serv de proxy reverso, ou seja, toda requisicao vai bater no nginx, ele vai chamar outro container PHP, o PHP vai retornar para o
Nginx e o Nginx vai retornar para o usuário final.
Para fazermos isso, vamos rodar o PHP no modo fast-cgi(eu acho q eh esse o nome).
Vamos utilizar o alpine linux para reduzir o tamanho da img.

Como vamos utilizar o Alpine, vamos aprender a trabalhar com multi-staged-building. A ideia dele, é quef azemos o processo de build
da img em 1 ou 2 etapas.
Tenho o stage inicial, o próximo otimizamos a img.

Toda vez que mudarmos a nomenclatura

parei em 10:29 do video "Otimizando Imagens - Otimizacao utilizando Multistage Building", antes de dar problema e congelar na etapa do chown